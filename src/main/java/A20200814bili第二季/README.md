
## 2 volatile是什么？
    
    1.vloatile是java虚拟机提供的轻量级的同步机制。
        ·保证可见性：一个线程在工作内存中修改完后，写回主内存，并且及时通知给其他线程，【主内存值一改变，就及时通知给其他线程】
        ·不保证原子性：
        ·禁止指令重排

## 3 JMM内存模型之可见性

    2.JMM（java内存模型-java Memory Model）
        ·是个抽象概念-实际并不存在
        ·描述的是一种规范规则，通过规范定义了程序中的各个变量(包含实例字段，静态字段，构成数组对象的元素)的访问方式
        ·jmm关于同步的规定：
            1.线程解锁前，必须把共享变量的值刷新回主内存
            2.线程加锁前，必须读取主内存到最新的自己的工作内存
            3.加锁，解锁是同一把锁
        ·由于jvm运行程序的实体是线程，而每个线程创建时，jvm都会为其创建一个工作内存（有些地方称为栈空间），工作内存是每个线程的私有数据区域，
            而java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值）都必须在自己的
            工作内存中进行，首先要将变量从主内存中拷贝到自己的工作内存中，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中变量
            ，各个线程的工作内存中存储着主内存的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程之间的通信必须是通过主内存来完成。
        ·cpu查看工具：www.cpuid.com
    3.jMM:
        可见性
        原子性
        有序性    
        
## 4 可见性的代码验证：同级目录下 code/A4Test_volatile
    
    1.内存可见性：线程AAA修改了共享变量X的值但是还未写会主内存时，另外一个线程BBB又对主内存中同一个共享变量X进行操作，但是此时AAA线程工作内存中共享变量X对线程B来说并不可见，
            所以出现了不可见的问题，而volatile则保证了内存可见性

## 5 volatile不保证原子性？code/A5Test_volatile
    
    1.原子性：不可分割，完整性，即某个线程在做某个具体业务时，中间不可以被加塞或者被分割，需要整体完整。
    2.解释：i++操作，多个线程同时操作变量i，进行++，此时的值小于等于单线程下的i++，所以不保证原子性
    
## 6 volatile不保证原子性的理论解释
    
    1.测试案例中，若对变量加了volatile，且进行i++时加了synchronized，则能保证原子性
    2.数据演示：
        Mydata5.java => Mydata5.class => JVM字节码
        Mydata5中的
        num++;
            n++被拆分成3个指令：
                ·执行getfield拿到原始n
                ·执行iadd进行加1操作
                ·执行putfield把累加后的值写回主内存
        写覆盖-造成值不对

## 7 不保证原子性的问题解决

    1.加synchronized保证原子性：不建议
    2.使用AtomicInteger保证原子性，AtomicInteger num = new AtomicInteger();默认值为0，底层主要是 CAS和自旋锁，之后题目会提到
    
## 8 volatile指令重排案例1 - 汇编编译原理
    
    1.概念：计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排，一般分为以下三种：
        源代码 -> [编译器优化重排]->[指令并行的重排]->[内存系统的重排] -> 最终执行的命令
    2.结论：
        ·单线程环境里确保程序最终执行结果和代码顺序执行结果一致
        ·处理器在进行重排序时必须要考虑指令直接的数据依赖性
        ·多线程环境下线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测
    3.示例1：
        public void sort(){
            int x = 11;//语句1
            int y = 20;//语句2
            x = x + 5;//语句3
            y = x * x;//语句4
        }
        单线程下正常执行
        多线程下可能会被重排，重排后的可能性有：1234,2134，1324
        问题：语句可以重排后到第一条吗？不可以，处理器在进行重排序时必须要考虑指令直接的数据依赖性
    
    
    
    
