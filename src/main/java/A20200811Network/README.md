# https://github.com/a982338665/lf-mkd-java-win-sock-demo.git



## http

## keepalive

## telnet

## 1.一个电脑有几个网卡？网卡mac地址，m地址修改有什么意义？

    1.笔记本电脑一般有两块网卡，一个PCI网卡，一个WireLess无线网卡。
    2.当我们安装虚拟机后，会有虚拟网卡，比如安装vmware，自动增加两个虚拟网卡：
        VMnet1和VMnet8，VMnet1是虚拟机主机模式的网卡，VMnet8是虚拟机的NAT模式网卡。
    3.每个网卡上都有单独的硬件地址，mac地址，全球唯一
        mac地址：全称Media Access Control Address
        介质访问地址，又名硬件地址
        每个网卡都有全球唯一的mac地址，跟mac电脑不是一个意思
    4.windows查看mac：
        ipconfig /all
        其中，物理地址为本机的MAC地址。
    5.linux查看mac：
        1.linux：
            ifconfig
            其中，HWaddr字段就是mac地址。
        2.centos：
            cat etc/sysconfig/network-scripts/ifcfg-eth0
            cat /sys/class/net/eth0/address
            demsg | grep eth
            ifconfig eth0 | grep HWaddr
    6.注意：网卡mac是可以修改的，
    7.修改mac的用途：
        一些公司,学校等都会对网络进行统一管理,其中一个很重要的统一管理是就是根据网卡的物理地址绑定IP地址。如果你在公司上网，进行BT下载，QQ上网等违反了规定的，
        网管就可以根据你所登记的网卡地址封了你的IP地址。
        要解决IP被封的问题根本就是要修改网卡地址，修改网卡MAC地址有多种方法：
        一、直接修改
            打开网络连接，在“本地连接”的小电脑图标，右键打开“属性”。
            点击上图的配置，在下图选择“Network Address”，然后在右侧的“值”中输入12个十六进制的数字（注意，mac地址每一位从0－F都是合法的，如00-50-8D-11-2F-9B，前3个字节表示制造商，
            后三个字节表示编号），单击“确定”保存设置，之后停用网络，在启用网络便可（或者重启电脑）

## 2.IP地址？

    1.ip地址：门牌号的作用，每个网卡、机器都有一个或多个ip地址
        ·IPv4：采用32位地址长度，只有大约43亿个地址
        ·IPv6：采用128位地址长度，几乎可以不受限制地提供地址
            ·解决地址短缺问题
            ·端到端IP连接
            ·服务质量（QoS）
            ·安全性
            ·多播
            ·移动性
            ·即插即用等
        -IPV4：192.168.0.100 每段0-255
        -IPV6:128bit长，分成8段，每段4个16进制数
    2.ip协议：也叫因特网协议，是所有计算机能在因特网上实现互通的原因，即各种设备基本单元的格式不同，需要转换为统一格式（IP数据报），来实现互通
    3.类型：
        ·公有地址：
            由Inter NIC（Internet Network Information Center因特网信息中心）负责。这些IP地址分配给注册并向Inter NIC提出申请的组织机构。通过它直接访问因特网。
        ·私有地址：
            私有地址（Private address）属于非注册地址，专门为组织机构内部使用。
            A类 10.0.0.0--10.255.255.255
            B类 172.16.0.0--172.31.255.255
            C类 192.168.0.0--192.168.255.255
    4.ip分配：
        TCP/IP协议需要针对不同的网络进行不同的设置，且每个节点一般需要一个“IP地址”、一个“子网掩码”、一个“默认网关”。不过，可以通过动态主机配置协议（DHCP），
        给客户端自动分配一个IP地址，避免了出错，也简化了TCP/IP协议的设置。
        IP地址现由因特网名字与号码指派公司ICANN（Internet Corporation for Assigned Names and Numbers）分配。
        InterNIC：负责美国及其他地区；
        ENIC：负责欧洲地区；
        APNIC（Asia Pacific Network Information Center）：　我国用户可向APNIC申请（要缴费）
        PS：1998年，APNIC的总部从东京搬迁到澳大利亚布里斯班。
        负责A类IP地址分配的机构是ENIC
        负责北美B类IP地址分配的机构是InterNIC
        负责亚太B类IP地址分配的机构是APNIC    

## 3.端口？
    
    1.分类：
        物理端口：又称接口
            ·计算机背板的RJ45网口，
            ·交换机路由器集线器等RJ45端
            ·电话使用RJ11插口也属于物理端口的范畴
        虚拟端口：
            ·80端口等
    2.分类2：
        硬件端口
        网络端口
        软件端口
    3.协议端口：
        1.如果把IP地址比作一间房子 ，端口就是出入这间房子的门。真正的房子只有几个门，但是一个IP地址的端口可以有65536（即：2^16）个之多！端口是通过端口号来标记的，
            端口号只有整数，范围是从0 到65535（2^16-1）。
        2.详情：
            ·范围：0-65535
            ·0-1023：一般被用作知名服务器的端口，被预定，如FTP、HTTP、SMTP等
        3.端口其实就是队，操作系统为各个进程分配了不同的队，数据包按照目的端口被推入相应的队中，等待被进程取用，在极特殊的情况下，这个队也是有可能溢出的，
            不过操作系统允许各进程指定和调整自己的队的大小。
            不光接受数据包的进程需要开启它自己的端口，发送数据包的进程也需要开启端口，这样，数据包中将会标识有源端口，以便接受方能顺利地回传数据包到这个端
    4.端口类型：
        1.周知端口：
            众所周知的端口，0-1023
            其中，服务于软件的可以更改
            其中，服务于系统协议使用固定的端口号，不能被改变，例如：139 端口专门用于NetBIOS与TCP/IP之间的通信
        2.动态端口
            动态端口的范围是从49152到65535。之所以称为动态端口，是因为它 一般不固定分配某种服务，而是动态分配。
        3.注册端口
            端口1024到49151，分配给用户进程或应用程序
    5.端口作用：
        1.入侵中的作用：
            入侵者通常会用扫描器对目标主机的端口进行扫描，以确定哪些端口是开放的，从开放的端口，入侵者可以知道目标主机大致提供了哪些服务，进而猜测可能存在的漏洞，
            因此对端口的扫描可以帮助我们更好的了解目标主机，而对于管理员，扫描本机的开放端口也是做好安全防范的第一步。
        2.分类：
            面向连接服务 - 电话
                建立连接--拨号
                等待应答后--相互传递信息
                最后还要释放连接--挂电话
            无连接服务   - 写信
                地址姓名填好以后直接往邮筒一扔
        3.TCP/IP协议在网络层是无连接的（数据包只管往网上发，如何传输和到达以及是否到达由网络设备来管理）。而"端口"，是传输层的内容，是面向连接的。
            协议里面低于1024的端口都有确切的定义，它们对应着因特网上常见的一些服务。

## 4.TCP/IP协议？Transmission Control Protocol/Internet Protocol，传输控制协议/网际协议 也称网络通讯协议
    
    1.定义：是指能够在多个不同网络间实现信息传输的协议簇。它并不是仅代表TCP协议和IP协议，而是指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇， 
        只是因为在TCP/IP协议中TCP协议和IP协议最具代表性，所以被称为TCP/IP协议
    2.简介：
        1.网络使用中最基本的通信协议
        2.规定了互联网通信标准和方法
        3.保证网络数据信息及时，完整的两个重要协议
        4.四层协议：
            应用层：
                主要协议：有Telnet、FTP、SMTP等
                接收：接收来自传输层的数据
                发送：按不同应用要求与方式将数据传输至传输层
            传输层:
                主要协议：有UDP、TCP
                是使用者使用平台和计算机信息网内部数据结合的通道，可以实现数据传输与数据共享
            网络层：
                主要协议：有ICMP、IP、IGMP
                主要负责网络中数据包的传送等
            数据链路层-网络访问层，也称网路接口层：
                主要协议：有ARP、RARP，
                主要功能：是提供链路管理错误检测、对不同通信媒介有关信息细节问题进行有效处理等
        5.TCP/IP协议组成:
            1.在一定程度上参考了OSI的体系结构，OSI七层模型，从上到下依次为：
                物理层、数据链路层、网络层、运输层、会话层、表示层和应用层,
            2.TCP/IP协议中合并为4层：
                应用层、表示层、会话层三个层次提供的服务相差不是很大，所以合为【应用层】
                数据链路层和物理层的内容相差不多，所以在TCP/IP协议中它们被归并在【网络接口层】一个层次里。
                由于【传输层】和【网络层】在网络协议中的地位十分重要，所以在TCP/IP协议中它们被作为独立的两个层次

## 5.三次握手四次挥手相关面试题？？
    
    1.请画出三次握手和四次挥手的示意图
    2.为什么连接的时候是三次握手？
    3.什么是半连接队列？
    4.ISN(Initial Sequence Number)是固定的吗？
    5.三次握手过程中可以携带数据吗？
    6.如果第三次握手丢失了，客户端服务端会如何处理？
    7.SYN攻击是什么？
    8.挥手为什么需要四次？
    9.四次挥手释放连接时，等待2MSL的意义?

    1.三次握手：
        1.本质：指建立一个TCP连接时，需要客户端和服务器总共发送3个包
        2.作用：确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备
        3.实质：连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息
        4.过程：客户端处于 Closed 的状态，服务端处于 Listen 状态。
            第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN©。此时客户端处于 SYN_SEND 状态。
                        首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。
            第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，
                        表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。
                        在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。
            第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，
                        此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接
                        确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。
            在socket编程中，客户端执行connect()时，将触发三次握手。
    2.为什么需要三次握手，两次，或者4次不行吗？
        结论：两次不够，4次多余
        握手目的：确认服务端，客户端收发能力正常
        第一次握手：客户端发送网络包，服务端收到了。
            这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
        第二次握手：服务端发包，客户端收到了。
            这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。
        第三次握手：客户端发包，服务端收到了。
            这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。
            因此，需要三次握手才能确认双方的接收与发送能力是否正常。
        两次握手的问题：
            客户端发出第一次连接请求：报文由于网络延缓或者丢失，服务端未确认，客户端进行重传
            客户端发出第二次连接请求：正常数据传输
            此时，第一次延缓的连接请求到达服务器，此时的服务端会认为这是一个新的请求，于是向客户端发送同意确认连接，
            若不是采用三次握手，此时就意味着连接已建立，但此时的客户端显然会忽略服务端发来的确认连接的消息，也不发送数据，
            所以服务端会处于等待状态，等待客户端发来数据，浪费资源
    3.什么是半连接队列，全连接队列？
        半连接队列：服务器第一次收到客户端的SYN之后就会处于 SYN_RCVD状态，此时还未完全建立连接，服务器会把此种状态放在一个队列中，这种队列就称为半连接队列。
        全连接队列：完成三次握手，建立了连接就会放在全连接队列中
        服务器SYNC-ACK重传次数问题：
            服务器发送完SYNC-ACK包：
                未收到客户确认包，服务器进行首次重传
                等待一段时间仍未收到客户确认包，进行第二次重传
                如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。
            注意：每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…
    4. ISN(Initial Sequence Number)是固定的吗？
        结论：不是
        解释：三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。
              如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的
    5.三次握手过程中可以携带数据吗？
        结论：第一次不能，第三次能，第二次是服务端回信，不会带数据
        解释：
            若第一次能携带数据，那么服务器就更容易被攻击，因为攻击者就不会理会服务器的接收，发送能力，只需要疯狂发syn报文，让服务器话很多内存，时间来处理接收这些报文
            第三次：因为此时客户端已经处于ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。
    6.SYN攻击问题？
        服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。
        SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，
        这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。
        检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。
        netstat -n -p TCP | grep SYN_RECV
        常见的防御 SYN 攻击的方法有如下几种：
            缩短超时（SYN Timeout）时间
            增加最大半连接数
            过滤网关防护
            SYN cookies技术
    7.四次挥手？
        原因：由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力
        目的：TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作
        过程：刚开始双方都处于 ESTABLISHED 状态
            客户端先发起关闭请求：
                1.第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。
                  即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。
                2.第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。
                  即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。
                  客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。
                3.第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。
                  即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认
                4.第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。
                  需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。
                  即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。
                  此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。
            收到一个FIN只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。
            在socket编程中，任何一方执行close()操作即可产生挥手操作。
    8.挥手为什么需要四次？
        因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，
        所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。
    9.2MSL等待状态
        TIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。
        这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。
        对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。
        这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。
        这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。
    10.四次挥手释放连接时，等待2MSL的意义?
        MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。
        为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，
        接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。
        两个理由：
            1.保证客户端发送的最后一个ACK报文段能够到达服务端。
                这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。
            2.防止“已失效的连接请求报文段”出现在本连接中。
                客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段
    11.为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？
       理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。
    
## 6.http请求与RPC调用问题？

    0.结论：根据不同业务场景灵活站位    
    1.http请求：Restful大有超过RPC的趋势
        优点：
            ·可读性好
            ·可得到防火墙支持，跨语言支持
        缺点：
            ·有用信息占比少：毕竟HTTP工作在第七层，包含了大量的HTTP头等信息
            ·效率低，还是因为第七层的缘故
            ·可读性似乎没有必要，因为我们可以引入网关增加可读性
            ·HTTP协议调用远程方法比较复杂，要封装各种参数名和参数值
    2.rpc请求精简
        支持长连接，减少了网络开销
        拥有注册中心，鼓舞治理更方便
        有监控，容易定位问题
        对调用方来说，无感知，统一化
    3.异同点：
        ·传输协议：
            RPC：可以基于TCP，也可以基于HTTP协议
            HTTP：基于http协议
        ·传输效率：
            RCP：使用自定义tcp协议，使请求报文体积更小
                或者使用HTTP2协议，减少报文体积，提高传输效率
            HTTP：
                基于http1.1,请求中会包含很多无用内容
                基于http2，简单封装可作为rpc使用
        ·性能比较：
            RPC：基于thrift实现高效的二进制传输
            http：大部分通过json实现，字节大小和序列化耗时比thrift更消耗性能
        ·负载均衡：
            RPC:自带负载均衡策略
            http：需要配置nginx
        ·服务治理：
            RPC：能自动通知，不影响上游
            http：需事先通知，更改nginx配置
        ·总结：
            RPC：主要用于公司内部服务调用，性能消耗低，传输效率高，服务治理方便
            http：主要用于对外的异构环境，浏览器调用，接口调用，第三方调用
