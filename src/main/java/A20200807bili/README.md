# 尚硅谷经典面试第一季
> https://www.bilibili.com/video/BV1Eb411P7bP

## 1 javase面试题 自增变量 Test

    public static void main(String[] args) {
            // int i  局部变量表：1   操作数栈：null
            int i = 1;
            //运算的过程是要把 值压进 操作数栈中
            //等号右边 i++ ： ++在后，后计算，先压栈
            //      1.压栈：把i的值压入操作数栈 此时，  局部变量表：1   操作数栈：1
            //      2.计算：i自增，此时，局部变量表：2   操作数栈：1
            //等号左边 i变量赋值 此时,将操作数栈的结果再赋值给 i ，即 i=1,在此过程中i是曾经变为2的，后面又变回1
            i = i++;
            //等号右边 i++ ： ++在后，后计算，先压栈
            //      1.压栈：把i的值压入操作数栈 此时，  局部变量表：1   操作数栈：1
            //      2.计算：i自增，此时，局部变量表：2   操作数栈：1
            //等号左边 j变量赋值,此时操作数栈结果1，i的结果为2（取局部变量表），操作数栈结果赋值给j，因此此时 i=2 j=1
            int j = i++;
            //等号右边：i + ++i * i++
            //      1.i压栈 局部变量表：2   操作数栈：2
            //      2.++i压栈，先++，就是先计算，后压栈，所以 ++i的压栈结果为
            //          1.计算后压栈：局部变量表：3 操作数栈：3
            //      3.i++压栈，++在后，后计算，先压栈
            //          1.压栈：把i的值压入操作数栈 此时，  局部变量表：3   操作数栈：3
            //          2.计算：i自增，此时，局部变量表：4   操作数栈：3
            //          3.i局部变量表变为 4 ，故i=4
            //等号右边计算：操作数栈结果分别为 2 3 3 ，计算为 2+3*3=11 赋值给 K ，所以k = 11
            int k = i + ++i * i++;
            //最后 i=4 j=1 k=11
            System.err.println("i=" + i);
            System.err.println("j=" + j);
            System.err.println("k=" + k);
    }
    注意：
        · 赋值 = ，最后计算
        · =右边的从左到右依次亚茹操作数栈，实际先算哪个，看运算符优先级
        · 自增，自减操作都是直接修改变量的值，不经过操作数栈，即直接修改局部变量表内的值
        · 赋值之前临时结果也 存储在操作数栈中
        · 更多详细查看 《java虚拟机规范》 关于指令的部分
        
        自增在变量，运算在栈中，栈中运算完，赋值变量中
    
## 2 单例设计模式 Test2
    
    1.定义：仅有一个实例能够被使用
    2.分类：
        饿汉式：先创建，线程安全，初始化后就生成了可用实例
        懒汉式：用的时候创建，双检锁+指令重排问题
    3.创建：构造方法私有化，属性私有化，对外提供获取实例的方法，或者构造方法私有化+对外提供公开的静态的单例实例的属性
        使用静态内部类实现单例进行延迟加载 - 懒汉式

## 3 类初始化和实例初始化  TestSon
    
    1.类初始化过程
        1.一个类要创建实例需要先加载并初始化该类
            ·main方法所在的类需要先加载和初始化
        2.一个子类要初始化需要先初始化父类
        3.一个类初始化就是执行<clinit>()方法，此方法由编译器生成，在.class文件中可以看见
            ·<clinit>()方法由静态类变量显示赋值代码和静态代码块组成
            ·类变量显示赋值代码和静态代码块从上到下执行，且只执行一次
    2.实例初始化过程
        1.实例初始化就是执行<init>()方法
            ·<init>()方法可能重载有多个，有几个构造器就有几个<init>方法
            ·由非静态实例变量显示赋值代码，非静态代码块，对应构造器代码组成
            ·非静态实例变量显示赋值代码，和非静态代码块从上到下顺序执行，对应的构造器代码最后执行
            ·每次创建实例对象，调用对应构造器，执行的就是对应的<init>()方法
            ·<init>方法的首行是super(),或super(实参列表)，及对应父类的<init>方法 
        2.方法重写问题：
            ·哪些方法不可以被重写：
                静态方法
                final方法
                private等子类中不可见的方法
            ·对象的多态性：非静态方法的重写
        3.重写的要求：
            ·方法名
            ·形参列表
            ·返回值类型
            ·抛出的异常列表
            ·修饰符
                1.重写方法的方法名和参数列表要和被重写方法一致。
                2.在 java 1.4版本以前，重写方法的返回值类型被要求必须与被重写方法一致，但是在java 5.0中放宽了这一个限制，添加了对协变返回类型的支持，
                    在重写的时候，重写方法的返回值类型可以是被重写方法返回值类型的子类。
                    示例代码如下：
                    class A{
                        public Object test(){
                        return null;
                      }
                    }
                    
                    class B extends A{
                        public String test(){
                            return null;
                        }
                    }
                    但是，对于基本数据类型，由于它们不是类，所以不能实现协变返回类型，但是使用对用的包装类则可以。
                3.重写方法不能使用比被重写方法更严格的权限，即重写方法的权限要大于或者等于被重写方法的权限。上面的代码如果改写成下面的样子将不能通过编译。
                    class A{
                        public Object test(){
                        return null;
                      }
                    }
                    class B extends A{
                        private String test(){
                            return null;
                        }
                    }
                    访问权限表：
                    修饰符	同一个类中	同一个包中	子类	不同包中
                    public	Yes	Yes	Yes	Yes
                    protected	Yes	Yes	Yes	
                    default	Yes	Yes		
                    private	Yes			
                4.private修饰不支持继承，所以无法重写private修饰的方法。static修饰的方法也不能被重写。虽然在子类中可以存在与父类中private方法和static方法相同名称的方法，
                    但是并不存在多态，所以并不是重写。
                    示例代码：
                    class Father{
                        private void method(){
                            System.out.println("父类的private方法");
                        }
                        static void staticMethod(){
                            System.out.println("父类的static方法");
                        }
                    
                        public static void main(String[] args){
                            Father son = new Son();
                            son.method();
                            son.staticMethod();
                    
                            Son son1 = new Son();
                            son1.method();
                            son1.staticMethod();
                        }
                    }
                    
                    class Son extends Father{
                        public void method(){
                            System.out.println("子类的private方法");
                        }
                        static void staticMethod(){
                            System.out.println("子类的static方法");
                        }
                    }
                5.重写方法声明抛出的异常不能比被重写方法宽泛，即不抛出异常或者抛出被重写方法中抛出异常的子类。
                
## 4 方法的参数传递机制 Test3

    1.形参是基本数据类型：传递数据值
    2.实参是引用数据类型：
        传递地址值
        特殊类型：String，包装类等对象的不可变性
      
## 5 递归与迭代 Test4

    有N步台阶，每次只能1步或2步，共有多少种走法:一步走了x ，两部走了y，那么x和y的所有解即为答案
    1.递归：
        N       走法                      走法数量
        n=1     一步                      1 种走法  
        n=2     一步一步/直接两步         2 种走法
        ========================================== 以上为基础 走一步的走法有一种，走两步的走法有两种
        n=3     
                先到f(2) 再f(1)           f(3) = f(2) + f(1) = 3
                先到f(1) 再f(2)           
        n=4     
                先到f(3) 在f(1)           f(4) = f(2) + f(3) = 5
                先到f(2) 在f(2)           f(4) = 2f(2)+f(1)
        n=5
                先到f(4) 在f(1)           f(5) = f(4) + f(3) = 8    
                先到f(3) 在f(2)           f(5) = 3f(2)+2f(1) = 6+2 =8
        ========================================== 离最后走完要么一步，要么两步所以
        n=x
                先到f(x-1) 在f(1)           f(x) = f(x-1) + f(x-2)
                先到f(x-2) 在f(2)           f(x) = f(x-1) + f(x-2)
        所以结果为：
             public static  int f(int x){
                    if(x==1 || x==2){
                        return x;
                    }else{
                        return f(x-2)+f(x-1);
                    }
             }
    2.迭代：
         N       走法                      走法数量                   累加临时值
         n=1     一步                      1 种走法  f(1) = 1         x = 1   
         n=2     一步一步/直接两步         2 种走法  f(2) = 2         y = 2
         ========================================== 以上为基础 走一步的走法有一种，走两步的走法有两种
         n=3     
                 先到f(2) 再f(1)           f(3) = f(2) + f(1) = 3
                 先到f(1) 再f(2)           第三次循环sum = f(3) = 2+1 = 3 同时为下次循环做准备  f(2)=2 f(3)=3  x=2 y=3
         n=4     
                 先到f(3) 在f(1)           f(4) = f(2) + f(3) = 5
                 先到f(2) 在f(2)           第四次循环sum = f(4) = 2+3 = 5 同时为下次循环做准备  f(4)=5 f(3)=3  x=3 y=5
         n=5
                 先到f(4) 在f(1)           f(5) = f(4) + f(3) = 8    
                 先到f(3) 在f(2)           
         ========================================== 离最后走完要么一步，要么两步所以
         n=x
                 先到f(x-1) 在f(1)           f(x) = f(x-1) + f(x-2)
                 先到f(x-2) 在f(2)           f(x) = f(x-1) + f(x-2)
    3.结语：   
        ·掉自己称为递归，利用变量原值推出新值称为迭代
        ·递归：
            优点：大问题转小问题，代码量小，精简，可读性好
            缺点：浪费空间，易造成堆栈溢出
        ·迭代：
            优点：代码运行效率好，无额外空间开销
            缺点：代码不如递归简洁，可读性差

## 6 成员变量与局部变量

    1.变量就近原则
    2.变量分类：
        ·成员变量：类中方法外
            类变量：static修饰的
            实例变量：无static修饰的
            修饰符：private public protected final static volatile transient
        ·局部变量
            方法体，形参，代码块中申明的
            修饰符：final
    3.非静态代码块的执行：每次创建实例对象都会执行
    4.方法调用规则：掉一次执行一次
    5.静态变量的值跟随的是类，而非对象，所以不管有几个对象都会网上累加
    6.值存储位置：
        ·局部变量：栈
        ·实例变量：堆（存放实例对象）
        ·类变量：方法区（用于存储被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据）
    7.作用域：
        ·局部变量：{开始，}结束
        ·实例变量：this.调用（可缺省，但是同名情况下调用需要指定），外部通过 对象.调用
        ·类变量：类名.变量名 直接调用
    8.生命周期：
        ·局部变量：每一个线程，每次调用执行都是一个新的生命周期
        ·实例变量：需要等待垃圾回收
        ·类变量：随着类的初始化而初始化，随类的卸载而消亡，该类所有的类变量都是共享的
        
    
